<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides a high performance, low level 2D rasterization library with support for rendering paths of various styles into alpha or subpixel masks."><title>zeno - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zeno" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../zeno/index.html">zeno</a><span class="version">0.2.3</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">zeno</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/zeno/lib.rs.html#1-307">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides a high performance, low level 2D rasterization library
with support for rendering paths of various styles into alpha or subpixel
masks.</p>
<p>Broadly speaking, support is provided for the following:</p>
<ul>
<li>256x anti-aliased rasterization (8-bit alpha or 32-bit RGBA subpixel alpha)</li>
<li>Pixel perfect hit testing with customizable coverage threshold</li>
<li>Non-zero and even-odd fills</li>
<li>Stroking with the standard set of joins and caps
(separate start and end caps are possible)</li>
<li>Numerically stable dashing for smooth dash offset animation</li>
<li>Vertex traversal for marker placement</li>
<li>Stepped distance traversal for animation or text-on-path support</li>
<li>Abstract representation of path data that imposes no policy on storage</li>
</ul>
<p>While this crate is general purpose, in the interest of interoperability and
familiarity, the feature set was chosen specifically to accommodate the
requirements of the
<a href="https://www.w3.org/TR/SVG/paths.html">SVG path specification</a>.</p>
<p>Furthermore, the rasterized masks are nearly identical to those generated by
Skia (sans slight AA differences) and as such, should yield images that are
equivalent to those produced by modern web browsers.</p>
<h2 id="rendering"><a href="#rendering">Rendering</a></h2>
<p>Due to the large configuration space for styling and rendering paths, the
builder pattern is used pervasively. The <a href="struct.Mask.html">Mask</a> struct is the
builder used for rasterization. For example, to render a simple triangle
into a 64x64 8-bit alpha mask:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Mask, PathData};

<span class="comment">// The target buffer that will contain the mask
</span><span class="kw">let </span><span class="kw-2">mut </span>mask = [<span class="number">0u8</span>; <span class="number">64 </span>* <span class="number">64</span>];

<span class="comment">// Create a new mask with some path data
</span>Mask::new(<span class="string">&quot;M 8,56 32,8 56,56 Z&quot;</span>)
    <span class="comment">// Choose an explicit size for the target
    </span>.size(<span class="number">64</span>, <span class="number">64</span>)
    <span class="comment">// Finally, render the path into the target
    </span>.render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>Note that, in this case, the path itself is supplied as a string in SVG path
data format. This crate provides several different kinds of path data by
default along with support for custom implementations. See the
<a href="trait.PathData.html">PathData</a> trait for more detail.</p>
<p>The previous example did not provide a style, so a non-zero
<a href="enum.Fill.html">Fill</a> was chosen by default. Let’s render the same path with
a 4 pixel wide stroke and a round line join:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Join, Mask, PathData, Stroke};

<span class="kw">let </span><span class="kw-2">mut </span>mask = [<span class="number">0u8</span>; <span class="number">64 </span>* <span class="number">64</span>];

Mask::new(<span class="string">&quot;M 8,56 32,8 56,56 Z&quot;</span>)
    .size(<span class="number">64</span>, <span class="number">64</span>)
    .style(Stroke::new(<span class="number">4.0</span>).join(Join::Round))
    .render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>Or to make it a bit more dashing:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Cap, Join, Mask, PathData, Stroke};

<span class="kw">let </span><span class="kw-2">mut </span>mask = [<span class="number">0u8</span>; <span class="number">64 </span>* <span class="number">64</span>];

Mask::new(<span class="string">&quot;M 8,56 32,8 56,56 Z&quot;</span>)
    .style(
        Stroke::new(<span class="number">4.0</span>)
            .join(Join::Round)
            .cap(Cap::Round)
            <span class="comment">// dash accepts a slice of dash lengths and an initial dash offset
            </span>.dash(<span class="kw-2">&amp;</span>[<span class="number">10.0</span>, <span class="number">12.0</span>, <span class="number">0.0</span>], <span class="number">0.0</span>),
    )
    .size(<span class="number">64</span>, <span class="number">64</span>)
    .render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>See the <a href="struct.Stroke.html">Stroke</a> builder struct for all available options.</p>
<p>So far, we’ve generated our masks into fixed buffers with explicit sizes. It is
often the case that it is preferred to ignore all empty space and render a path
into a tightly bound mask of dynamic size. This can be done by eliding the call
for the size method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Mask, PathData};

<span class="comment">// Dynamic buffer that will contain the mask
</span><span class="kw">let </span><span class="kw-2">mut </span>mask = Vec::new();

<span class="kw">let </span>placement = Mask::new(<span class="string">&quot;M 8,56 32,8 56,56 Z&quot;</span>)
    <span class="comment">// Insert an inspect call here to access the computed dimensions
    </span>.inspect(|format, width, height| {
        <span class="comment">// Make sure our buffer is the correct size
        </span>mask.resize(format.buffer_size(width, height), <span class="number">0</span>);
    })
    .render_into(<span class="kw-2">&amp;mut </span>mask, <span class="prelude-val">None</span>);</code></pre></div>
<p>The call to size has been replaced with a call to inspect which injects a
closure into the call chain giving us the opportunity to extend our buffer to
the appropriate size. Note also that the render method has a return value that
has been captured here. This <a href="struct.Placement.html">Placement</a> struct
describes the dimensions of the resulting mask along with an offset that should
be applied during composition to compensate for the removal of any empty space.</p>
<p>Finally, it is possible to render without a target buffer, in which case the
rasterizer will allocate and return a new <code>Vec&lt;u8&gt;</code> containing the mask:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Mask, PathData};

<span class="comment">// mask is a Vec&lt;u8&gt;
</span><span class="kw">let </span>(mask, placement) = Mask::new(<span class="string">&quot;M 8,56 32,8 56,56 Z&quot;</span>)
    <span class="comment">// Calling render() instead of render_into() will allocate a buffer
    // for you that is returned along with the placement
    </span>.render();</code></pre></div>
<p>Both <a href="struct.Mask.html">Mask</a> and <a href="struct.Stroke.html">Stroke</a> offer large
sets of options for fine-grained control of styling and rasterization including
offsets, scaling, transformations, formats, coordinate spaces and more. See
their respective documentation for more detail.</p>
<h2 id="hit-testing"><a href="#hit-testing">Hit testing</a></h2>
<p>Hit testing is the process of determining if a point is within the region that
would be painted by the path. A typical use case is to determine if a user’s
cursor is hovering over a particular path. The process generally follows the
same form as rendering:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{HitTest, PathData};

<span class="comment">// A 20x10 region with the right half covered by the path
</span><span class="kw">let </span>hit_test = HitTest::new(<span class="string">&quot;M10,0 10,10 20,10 20,0 Z&quot;</span>);

<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">15</span>, <span class="number">5</span>]), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">5</span>, <span class="number">5</span>]), <span class="bool-val">false</span>);</code></pre></div>
<p>Due to the fact that paths are anti-aliased, the hit test builder offers a
threshold option that determines how much “coverage” is required for a hit test
to pass at a particular point.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{HitTest, PathData};

<span class="kw">let </span><span class="kw-2">mut </span>hit_test = HitTest::new(<span class="string">&quot;M2.5,0 2.5,2 5,2 5,0 Z&quot;</span>);

<span class="comment">// Require full coverage for a successful hit test
</span>hit_test.threshold(<span class="number">255</span>);
<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">2</span>, <span class="number">0</span>]), <span class="bool-val">false</span>);

<span class="comment">// Succeed for any non-zero coverage
</span>hit_test.threshold(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(hit_test.test([<span class="number">2</span>, <span class="number">0</span>]), <span class="bool-val">true</span>);</code></pre></div>
<p>See the <a href="struct.HitTest.html">HitTest</a> type for more detail.</p>
<h2 id="path-building"><a href="#path-building">Path building</a></h2>
<p>While SVG paths are a reasonable choice for static storage, there sometimes
arise cases where paths must be built dynamically at runtime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Command, Mask, PathBuilder, PathData};

<span class="comment">// Create a vector to store the path commands
</span><span class="kw">let </span><span class="kw-2">mut </span>path: Vec&lt;Command&gt; = Vec::new();

<span class="comment">// Construct the path with chained method calls
</span>path.move_to([<span class="number">8</span>, <span class="number">56</span>]).line_to([<span class="number">32</span>, <span class="number">8</span>]).line_to([<span class="number">56</span>, <span class="number">56</span>]).close();

<span class="comment">// Ensure it is equal to the equivalent SVG path
</span><span class="macro">assert!</span>((<span class="kw-2">&amp;</span>path).commands().eq(<span class="string">&quot;M 8,56 32,8 56,56 Z&quot;</span>.commands()));

<span class="comment">// &amp;Vec&lt;Command&gt; is also valid path data
</span>Mask::new(<span class="kw-2">&amp;</span>path).render(); <span class="comment">// ...</span></code></pre></div>
<p>Here, a vector of <a href="enum.Command.html">Command</a>s is used to store the path data
and the <a href="trait.PathBuilder.html">PathBuilder</a> trait provides the extension
methods necessary for building a path.</p>
<p>Beyond the four basic path commands, the path builder trait also provides
arcs (and position relative versions of all previous commands) along with
rectangles, round rectangles, ellipses and circles:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{Angle, ArcSize, ArcSweep, Command, PathBuilder, PathData};

<span class="kw">let </span><span class="kw-2">mut </span>path: Vec&lt;Command&gt; = Vec::new();

path.move_to([<span class="number">1</span>, <span class="number">2</span>]).rel_arc_to(
    <span class="number">8.0</span>,
    <span class="number">4.0</span>,
    Angle::from_degrees(<span class="number">30.0</span>),
    ArcSize::Small,
    ArcSweep::Positive,
    [<span class="number">10</span>, <span class="number">4</span>],
);

<span class="macro">assert!</span>((<span class="kw-2">&amp;</span>path).commands().eq(<span class="string">&quot;M1,2 a8,4,30,0,1,10,4&quot;</span>.commands()));</code></pre></div>
<p>Along with incremental building of paths, path builder can also be used as a
“sink” for capturing the result of the application of a style and transform
to some path data. For example, it is possible to store the output of a stroke
style to avoid the cost of stroke evaluation for future rendering or hit test
operations with the use of the <a href="fn.apply.html">apply</a> function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>zeno::{apply, Cap, Command, PathBuilder, PathData, Stroke};

<span class="kw">let </span><span class="kw-2">mut </span>stroke: Vec&lt;Command&gt; = Vec::new();

apply(<span class="string">&quot;L10,0&quot;</span>, Stroke::new(<span class="number">4.0</span>).cap(Cap::Round), <span class="prelude-val">None</span>, <span class="kw-2">&amp;mut </span>stroke);</code></pre></div>
<p><a href="struct.PathBuilder.html">PathBuilder</a> is only implemented for <code>Vec&lt;Command&gt;</code>
by default, but custom implementations are possible to support capturing
and building paths into other data structures.</p>
<h2 id="traversal"><a href="#traversal">Traversal</a></h2>
<p>Path traversal involves incremental evaluation of a path by some metric. This
crate currently provides two methods of traversal.</p>
<p>The <a href="struct.Vertices.html">Vertices</a> iterator yields a variant of the
<a href="enum.Vertex.html">Vertex</a> enum at the beginning and end of each subpath and
between each path command. Each variant provides all the geometric
information necessary to place SVG style markers.</p>
<p>The <a href="struct.Walk.html">Walk</a> type is an iterator-like type that allows for
stepping along the path by arbitrary distances. Each step yields the position
on the path at the next distance along with a vector describing the
left-ward direction from the path at that point. This is useful for animating
objects along a path, or for rendering text attached to a path.</p>
<h2 id="transient-memory-allocations"><a href="#transient-memory-allocations">Transient memory allocations</a></h2>
<p>The algorithms in this crate make a concerted effort to avoid dynamic
allocations where possible, but paths of significant size or complexity
may cause spills into temporary heap memory. Specifically, stroke evaluation
and rasterization may cause heap allocations.</p>
<p>To amortize the cost of these, the appropriately named
<a href="struct.Scratch.html">Scratch</a> struct is available. This type contains internal
heap allocated storage and provides replacement methods for functions that may
allocate. In addition, the
<a href="struct.Mask.html#method.with_scratch">Mask::with_scratch</a> and
<a href="struct.HitTest.html#method.with_scratch">HitTest::with_scratch</a>
constructors are provided which take a scratch instance as an argument and
redirect all transient allocations to the reusable storage.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Angle.html" title="struct zeno::Angle">Angle</a></div><div class="desc docblock-short">Represents an angle in degrees or radians.</div></li><li><div class="item-name"><a class="struct" href="struct.Bounds.html" title="struct zeno::Bounds">Bounds</a></div><div class="desc docblock-short">Axis-aligned bounding box.</div></li><li><div class="item-name"><a class="struct" href="struct.HitTest.html" title="struct zeno::HitTest">HitTest</a></div><div class="desc docblock-short">Builder for configuring and executing a hit test.</div></li><li><div class="item-name"><a class="struct" href="struct.Mask.html" title="struct zeno::Mask">Mask</a></div><div class="desc docblock-short">Builder for configuring and rendering a mask.</div></li><li><div class="item-name"><a class="struct" href="struct.Placement.html" title="struct zeno::Placement">Placement</a></div><div class="desc docblock-short">Describes the offset and dimensions of a rendered mask.</div></li><li><div class="item-name"><a class="struct" href="struct.Scratch.html" title="struct zeno::Scratch">Scratch</a></div><div class="desc docblock-short">Scratch memory for reusable heap allocations.</div></li><li><div class="item-name"><a class="struct" href="struct.Stroke.html" title="struct zeno::Stroke">Stroke</a></div><div class="desc docblock-short">Describes the visual style of a stroke.</div></li><li><div class="item-name"><a class="struct" href="struct.Transform.html" title="struct zeno::Transform">Transform</a></div><div class="desc docblock-short">Two dimensional transformation matrix.</div></li><li><div class="item-name"><a class="struct" href="struct.Vector.html" title="struct zeno::Vector">Vector</a></div><div class="desc docblock-short">Two dimensional vector.</div></li><li><div class="item-name"><a class="struct" href="struct.Vertices.html" title="struct zeno::Vertices">Vertices</a></div><div class="desc docblock-short">An iterator over the vertices of a path.</div></li><li><div class="item-name"><a class="struct" href="struct.Walk.html" title="struct zeno::Walk">Walk</a></div><div class="desc docblock-short">An iterator like type that walks along a path by arbitrary steps.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ArcSize.html" title="enum zeno::ArcSize">ArcSize</a></div><div class="desc docblock-short">Describes the size of an arc.</div></li><li><div class="item-name"><a class="enum" href="enum.ArcSweep.html" title="enum zeno::ArcSweep">ArcSweep</a></div><div class="desc docblock-short">Describes the sweep direction for an arc.</div></li><li><div class="item-name"><a class="enum" href="enum.Cap.html" title="enum zeno::Cap">Cap</a></div><div class="desc docblock-short">Defines the shape to be drawn at the beginning or end of a stroke.</div></li><li><div class="item-name"><a class="enum" href="enum.Command.html" title="enum zeno::Command">Command</a></div><div class="desc docblock-short">Path command.</div></li><li><div class="item-name"><a class="enum" href="enum.Fill.html" title="enum zeno::Fill">Fill</a></div><div class="desc docblock-short">Describes the visual style of a fill.</div></li><li><div class="item-name"><a class="enum" href="enum.Format.html" title="enum zeno::Format">Format</a></div><div class="desc docblock-short">The desired output image format for rendering.</div></li><li><div class="item-name"><a class="enum" href="enum.Join.html" title="enum zeno::Join">Join</a></div><div class="desc docblock-short">Defines the connection between two segments of a stroke.</div></li><li><div class="item-name"><a class="enum" href="enum.Origin.html" title="enum zeno::Origin">Origin</a></div><div class="desc docblock-short">The origin of the coordinate system for rendering.</div></li><li><div class="item-name"><a class="enum" href="enum.Style.html" title="enum zeno::Style">Style</a></div><div class="desc docblock-short">Represents the style of a path for rendering or hit testing.</div></li><li><div class="item-name"><a class="enum" href="enum.Verb.html" title="enum zeno::Verb">Verb</a></div><div class="desc docblock-short">Action of a path command.</div></li><li><div class="item-name"><a class="enum" href="enum.Vertex.html" title="enum zeno::Vertex">Vertex</a></div><div class="desc docblock-short">A vertex of a path.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.PathBuilder.html" title="trait zeno::PathBuilder">PathBuilder</a></div><div class="desc docblock-short">Trait for types that accept path commands.</div></li><li><div class="item-name"><a class="trait" href="trait.PathData.html" title="trait zeno::PathData">PathData</a></div><div class="desc docblock-short">Trait for types that represent path data.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.apply.html" title="fn zeno::apply">apply</a></div><div class="desc docblock-short">Applies the style and transform to the path and emits the result to the
specified sink.</div></li><li><div class="item-name"><a class="fn" href="fn.bounds.html" title="fn zeno::bounds">bounds</a></div><div class="desc docblock-short">Computes the bounding box of the path.</div></li><li><div class="item-name"><a class="fn" href="fn.length.html" title="fn zeno::length">length</a></div><div class="desc docblock-short">Computes the total length of the path.</div></li><li><div class="item-name"><a class="fn" href="fn.validate_svg.html" title="fn zeno::validate_svg">validate_svg</a></div><div class="desc docblock-short">Returns an error indicating the first position of invalid SVG path data.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Point.html" title="type zeno::Point">Point</a></div><div class="desc docblock-short">Alias for vector to distinguish intended use.</div></li></ul></section></div></main></body></html>